<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>RabbitMQ学习笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RabbitMQ基本概念和特性MQ全称Message Queue消息队列,RabbitMQ是基于AMQP(高级消息队列协议)实现的。  消息队列通常用以应用之间相互通信解决同步问题.MQ是典型的生产者消费者模型,RabbitMQ最常用的三种模式是Direct模式、Topic模式、Fanout模式.    RabbitMQ特性 1、Reliabliity(可靠性): RabbitMQ offers">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/08/05/RabbitMQ学习笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="RabbitMQ基本概念和特性MQ全称Message Queue消息队列,RabbitMQ是基于AMQP(高级消息队列协议)实现的。  消息队列通常用以应用之间相互通信解决同步问题.MQ是典型的生产者消费者模型,RabbitMQ最常用的三种模式是Direct模式、Topic模式、Fanout模式.    RabbitMQ特性 1、Reliabliity(可靠性): RabbitMQ offers">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.imgur.com/TXsyyY0.png">
<meta property="og:image" content="https://i.imgur.com/sMmUan1.png">
<meta property="og:image" content="https://i.imgur.com/uPsgpJ2.png">
<meta property="og:image" content="https://i.imgur.com/6gleXbF.png">
<meta property="og:image" content="https://i.imgur.com/j1dLchP.png">
<meta property="og:updated_time" content="2018-08-11T03:39:13.734Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RabbitMQ学习笔记">
<meta name="twitter:description" content="RabbitMQ基本概念和特性MQ全称Message Queue消息队列,RabbitMQ是基于AMQP(高级消息队列协议)实现的。  消息队列通常用以应用之间相互通信解决同步问题.MQ是典型的生产者消费者模型,RabbitMQ最常用的三种模式是Direct模式、Topic模式、Fanout模式.    RabbitMQ特性 1、Reliabliity(可靠性): RabbitMQ offers">
<meta name="twitter:image" content="https://i.imgur.com/TXsyyY0.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-RabbitMQ学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/05/RabbitMQ学习笔记/" class="article-date">
  <time datetime="2018-08-05T09:47:53.043Z" itemprop="datePublished">2018-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MQ消息中间件/">MQ消息中间件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RabbitMQ学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RabbitMQ基本概念和特性"><a href="#RabbitMQ基本概念和特性" class="headerlink" title="RabbitMQ基本概念和特性"></a>RabbitMQ基本概念和特性</h2><pre><code>MQ全称Message Queue消息队列,RabbitMQ是基于AMQP(高级消息队列协议)实现的。

消息队列通常用以应用之间相互通信解决同步问题.MQ是典型的生产者消费者模型,RabbitMQ最常用的三种模式是Direct模式、Topic模式、Fanout模式.
</code></pre><center><img src="https://i.imgur.com/TXsyyY0.png" alt="生产者消费者模型"></center>

<hr>
<pre><code>RabbitMQ特性
1、Reliabliity(可靠性):
RabbitMQ offers a variety of features to let you trade off performance with reliability, including persistence, delivery acknowledgements, publisher confirms, and high availability.
2、Flexible Routing(灵活的路由机制):
Messages are routed through exchanges before arriving at queues. RabbitMQ features several built-in exchange types for typical routing logic. For more complex routing you can bind exchanges together or even write your own exchange type as a plugin.
3、Clustering(集群功能):
Several RabbitMQ servers on a local network can be clustered together, forming a single logical broker.
4、Highly Available Queues(高度可用队列):
Queues can be mirrored across several machines in a cluster, ensuring that even in the event of hardware failure your messages are safe.
5、Multi-protocol(多协议支持):
RabbitMQ supports messaging over a variety of messaging protocols.
6、Many Clients(多客户端支持):
There are RabbitMQ clients for almost any language you can think of.
7、Management UI(图形管理界面):
RabbitMQ ships with an easy-to use management UI that allows you to monitor and control every aspect of your message broker.

etc …
</code></pre><hr>
<h2 id="RabbitMQ应用场景"><a href="#RabbitMQ应用场景" class="headerlink" title="RabbitMQ应用场景"></a>RabbitMQ应用场景</h2><pre><code>1）信息的发送者和接收者如何维持这个连接，如果一方的连接中断，这期间的数据如何方式丢失？(宕机处理)
2）如何降低发送者和接收者的耦合度？(解耦)
3）如何让Priority高的接收者先接到数据？
4）如何做到load balance？有效均衡接收者的负载？(负载均衡)
5）如何有效的将数据发送到相关的接收者？也就是说将接收者subscribe 不同的数据，如何做有效的filter。(路由)
6）如何做到可扩展，甚至将这个通信模块发到cluster上？
7）如何保证接收者接收到了完整，正确的数据？(稳定性)
</code></pre><p><strong>总结:消息中间件主要的两个功能解耦和异步处理</strong></p>
<hr>
<h2 id="RabbitMQ安装介绍"><a href="#RabbitMQ安装介绍" class="headerlink" title="RabbitMQ安装介绍"></a>RabbitMQ安装介绍</h2><pre><code>1、rabbitMQ是由erlang语言开发的,所以必须先有安装erlang，类似java安装
2、rabbitMQ是C/S模式的，所以安装rabbitMQ服务器，傻瓜安装默认端口5672
3、推荐最好也安装上rabbitMQ 的web管理界面(默认端口15672) 当然使用rabbitctl命令也可以
</code></pre><hr>
<h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><pre><code>Producer:消息生产者
Consumer:消息消费者
Queue:缓存消息的容器(队列)
Message:消费者真正需要的消息数据
Connection:一个tcp连接(应用与MQ服务器的连接),相对比较耗资源
Channel:管道连接,是tcp连接内的连接,相对比较节约资源,大部分操作都是基于channel实现
Exchange:消息路由,生产者发送消息并不是直接发送到队列中的而是先到指定方式路由中，然后由路由根据路由key绑定的队列发送到指定队列中。
Binding:指队列和路由之间的绑定
Routing key:路由key,通过路由key路由到指定队列
AMQP:高级消息队列协议,RabbitMQ是基于此协议实现的
virtual host:主要作用就是用来隔离的
Users:RabbitMQ服务是基于C/S模式,通常连接都需要认证
</code></pre><hr>
<h2 id="RabbitMQ开发使用"><a href="#RabbitMQ开发使用" class="headerlink" title="RabbitMQ开发使用"></a>RabbitMQ开发使用</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><pre><code>1、获得与RabbitMQ服务器的连接

 ConnectionFactory factory = new ConnectionFactory();//创建连接工厂对象
 factory.setHost(hostName);//指定主机名
 factory.setPort(portNumber);//指定端口号
 factory.setVirtualHost(virtualHost);//指定RabbitMQ服务器的虚拟主机
 factory.setUsername(username);//指定连接用户名
 factory.setPassword(password);//指定连接用户密码
 Connection conn = factory.newConnection();//创建连接

备注:由于这个Conneciton连接是一个TCP连接相对比较耗资源,通常我们都会在其内部创建管道连接来操作RabbitMQ.

//open a channel
 Channel channel = conn.createChannel();

2、声明路由和使用的路由类型以及声明队列名称

3、发送消息Publish或接受消息Consume

备注:声明队列是幂等的,只有队列不存在时才会创建队列.
</code></pre><p><strong>RabbitMQ Consumer 获取消息的两种方式(poll、subscribe)</strong></p>
<pre><code>1、Subscribe订阅方式
代码如下:

Consumer consumer = new DefaultConsumer(channel) {
        public void handleDelivery(String consumerTag, com.rabbitmq.client.Envelope envelope,
                com.rabbitmq.client.AMQP.BasicProperties properties, byte[] body) throws java.io.IOException {
            //使用以上的几个入参来处理信息
            // doSomething ...
        };

2、poll API方式(轮询方式)

channel.basicGet(String queue, boolean autoAck);

备注:相比而言使用轮询方式效率更低效推荐使用订阅方式
</code></pre><hr>
<h2 id="RabbitMQ三种路由方式"><a href="#RabbitMQ三种路由方式" class="headerlink" title="RabbitMQ三种路由方式"></a>RabbitMQ三种路由方式</h2><center><img src="https://i.imgur.com/sMmUan1.png" alt=""></center>

<h3 id="一、Direct-Exchange-直接路由"><a href="#一、Direct-Exchange-直接路由" class="headerlink" title="一、Direct Exchange(直接路由)"></a>一、Direct Exchange(直接路由)</h3><pre><code>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。

1.一般情况可以使用rabbitMQ自带的Exchange:&quot;(该Exchange的名字为空字符串，下文称其为default Exchange)。
2.这种模式下不需要将Exchange进行任何绑定(binding)操作
3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。
4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。
</code></pre><center><img src="https://i.imgur.com/uPsgpJ2.png" alt="Direct模式"></center>


<h3 id="二、Fanout-Exchange-广播路由）"><a href="#二、Fanout-Exchange-广播路由）" class="headerlink" title="二、Fanout Exchange(广播路由）"></a>二、Fanout Exchange(广播路由）</h3><pre><code>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。

1.可以理解为路由表的模式
2.这种模式不需要RouteKey
3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。
4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃
</code></pre><center><img src="https://i.imgur.com/6gleXbF.png" alt="Fanout模式"></center>

<h3 id="三、Topic-Exchange-主题订阅模式路由"><a href="#三、Topic-Exchange-主题订阅模式路由" class="headerlink" title="三、Topic Exchange(主题订阅模式路由)"></a>三、Topic Exchange(主题订阅模式路由)</h3><pre><code>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上

1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。
2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。
3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。
4.“#”表示0个或若干个关键字，“*”表示一个关键字。如“log.*”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。
5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。
</code></pre><center><img src="https://i.imgur.com/j1dLchP.png" alt="Topic模式"></center>

<p><strong>备注:topic Exchange是三种模式中最灵活和最通用的模式，通常情况推荐使用.</strong></p>
<pre><code>Topic exchange is powerful and can behave like other exchanges.

When a queue is bound with &quot;#&quot; (hash) binding key - it will receive all the messages, regardless of the routing key - like in fanout exchange.

When special characters &quot;*&quot; (star) and &quot;#&quot; (hash) aren&apos;t used in bindings, the topic exchange will behave just like a direct one.
</code></pre><hr>
<h2 id="队列和消息属性配置-持久化、ack机制"><a href="#队列和消息属性配置-持久化、ack机制" class="headerlink" title="队列和消息属性配置(持久化、ack机制)"></a>队列和消息属性配置(持久化、ack机制)</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/05/RabbitMQ学习笔记/" data-id="cjkovjf3q0009hcl25lbu7nut" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/07/18/高性能MySQL之Schema与数据类型优化/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">高性能MySQL之:Schema与数据类型优化</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-SE/">Java SE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ消息中间件/">MQ消息中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高性能MySQL/">高性能MySQL</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/05/RabbitMQ学习笔记/">RabbitMQ学习笔记</a>
          </li>
        
          <li>
            <a href="/2018/07/18/高性能MySQL之Schema与数据类型优化/">高性能MySQL之:Schema与数据类型优化</a>
          </li>
        
          <li>
            <a href="/2018/07/14/JDBC学习笔记/">JDBC 学习笔记</a>
          </li>
        
          <li>
            <a href="/2018/07/08/使用vps科学上网/">使用vps科学上网</a>
          </li>
        
          <li>
            <a href="/2018/07/07/Linux学习笔记/">Linux 学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>